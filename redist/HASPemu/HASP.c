/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2206 from the
 * contents of HASP.xs. Do not edit this file, edit HASP.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "HASP.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "VNHASP.h"

#include <time.h>

int _getDateTime(int *s, int *min, int *h, int *d, int *mon, int *y)
{
	int p1, p2, p3, p4;

	time_t ctime = time(NULL);
	struct tm *time = localtime(&ctime);
	*s 	= time->tm_sec;
	*min	= time->tm_min;	
	*h	= time->tm_hour;
	*d 	= time->tm_mday;
	*mon 	= time->tm_mon;
	*y	= time->tm_year;

	return 0;
}

int _setDateTime(int s, int min, int h, int d, int mon, int y)
{
	int p1, p2, p3, p4;

	return 0;
}

#line 41 "HASP.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 93 "HASP.c"

XS(XS_VN__HASP_Attached); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_Attached)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 36 "HASP.xs"
#line 107 "HASP.c"
	int	RETVAL;
	dXSTARG;
#line 37 "HASP.xs"
	RETVAL = 0;
quit:
#line 113 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_VN__HASP_DecodeData); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_DecodeData)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
	SV *	data = ST(0);
#line 46 "HASP.xs"
#line 133 "HASP.c"
	int	RETVAL;
	dXSTARG;
#line 47 "HASP.xs"
	RETVAL = 1;
#line 138 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_VN__HASP_EncodeData); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_EncodeData)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "data");
    {
	SV *	data = ST(0);
#line 55 "HASP.xs"
#line 158 "HASP.c"
	int	RETVAL;
	dXSTARG;
#line 56 "HASP.xs"
	RETVAL = 1;
#line 163 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_VN__HASP_Id); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_Id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "id");
    {
	SV *	id = ST(0);
#line 64 "HASP.xs"
#line 183 "HASP.c"
	int	RETVAL;
	dXSTARG;
#line 65 "HASP.xs"
	sv_setiv(id, 0);
	SvSETMAGIC(id);
	RETVAL = 0;
#line 190 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_VN__HASP_ReadBlock); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_ReadBlock)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "data, length, addr");
    {
	int	length = (int)SvIV(ST(1));
	int	addr = (int)SvIV(ST(2));
	SV *	data = ST(0);
#line 77 "HASP.xs"
	size_t p1, p2, p3, p4;
	int r_a;
	char *buff;
	FILE *f;
#line 216 "HASP.c"
	int	RETVAL;
	dXSTARG;
#line 82 "HASP.xs"
	if(length < 0) length = 0;
	if(addr < 0) addr = 0;
//	p1 = addr / sizeof(WORD); r_a = addr % sizeof(WORD);
//	p2 = (length + r_a) / sizeof(WORD); p2 += (p2*sizeof(WORD) == (length + r_a)) ? 0 : 1;
	r_a = 0;
	p3 = 0;
//	New(0, buff, p2 * sizeof(WORD), char); p4 = (int) buff;
	New(0, buff, length * sizeof(WORD), char); p4 = (size_t) buff;
//	memset(buff, 0, p2*sizeof(WORD));
//	hasp(MEMOHASP_READBLOCK, SEEDCODE, 0, PASS1, PASS2, &p1, &p2, &p3, &p4);
//	if( f = fopen(HASP_DATA_FILE, "rb") ) {
	if( f = fopen(HASP_DATA_FILE, "r") ) {
		fseek(f, addr, SEEK_SET);
		fread(buff, 1, length, f); 
		fclose(f);
		*(buff+length) = 0;
//		fprintf(stderr, "readed %d from %d: '%s'\n", length, addr, buff);
	} else {
		p3 = errno;
	}
	sv_setpvn(data, buff + r_a, length);
	SvSETMAGIC(data);
	Safefree(buff);
	RETVAL = p3;
#line 244 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_VN__HASP_WriteBlock); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_WriteBlock)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "data, addr");
    {
	int	addr = (int)SvIV(ST(1));
	SV *	data = ST(0);
#line 115 "HASP.xs"
	size_t p1, p2, p3, p4;
	char *tmp, *buff;
	STRLEN len;
	int r_a;
	FILE *f;
#line 270 "HASP.c"
	int	RETVAL;
	dXSTARG;
#line 121 "HASP.xs"
	if(addr < 0) addr = 0;
	tmp = SvPV(data, len);
	p1 = addr / sizeof(WORD); r_a = addr % sizeof(WORD);
	p2 = (len + r_a) / sizeof(WORD); p2 += (p2*sizeof(WORD) == (len + r_a)) ? 0 : 1;
	New(0, buff, p2 * sizeof(WORD), char); p4 = (size_t) buff;
//	hasp(MEMOHASP_READBLOCK, SEEDCODE, 0, PASS1, PASS2, &p1, &p2, &p3, &p4);
	Copy(tmp, buff + r_a, len, char); p4 = (size_t) buff;
//	hasp(MEMOHASP_WRITEBLOCK, SEEDCODE, 0, PASS1, PASS2, &p1, &p2, &p3, &p4);
	if( f = fopen(HASP_DATA_FILE, "wb") ) {
		fseek(f, p1, SEEK_SET);
		fwrite(buff, 1, p2, f); 
		fclose(f);
	}
	RETVAL = 0;
	Safefree(buff);
#line 289 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_VN__HASP_SetDateTime); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_SetDateTime)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "s, min, h, d, mon, y");
    {
	int	s = (int)SvIV(ST(0));
	int	min = (int)SvIV(ST(1));
	int	h = (int)SvIV(ST(2));
	int	d = (int)SvIV(ST(3));
	int	mon = (int)SvIV(ST(4));
	int	y = (int)SvIV(ST(5));
	int	RETVAL;
	dXSTARG;
#line 148 "HASP.xs"
	RETVAL = _setDateTime(s, min, h, d, mon, y);
#line 317 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_VN__HASP_GetDateTime); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_GetDateTime)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "s, min, h, d, mon, y");
    {
	SV*	s = ST(0);
	SV*	min = ST(1);
	SV*	h = ST(2);
	SV*	d = ST(3);
	SV*	mon = ST(4);
	SV*	y = ST(5);
#line 161 "HASP.xs"
	int s_1, min_1, h_1, d_1, mon_1, y_1;
	int rv;
#line 344 "HASP.c"
	int	RETVAL;
	dXSTARG;
#line 164 "HASP.xs"
	rv = _getDateTime(&s_1, &min_1, &h_1, &d_1, &mon_1, &y_1);
	if(rv == 0) {
		sv_setiv(s, (IV) s_1);
		sv_setiv(min, (IV) min_1);
		sv_setiv(h, (IV) h_1);
		sv_setiv(d, (IV) d_1);
		sv_setiv(mon, (IV) mon_1);
		sv_setiv(y, (IV) y_1);
	}
	RETVAL = rv;
#line 358 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_VN__HASP_CompareTimeWithCurrent); /* prototype to pass -Wmissing-prototypes */
XS(XS_VN__HASP_CompareTimeWithCurrent)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "s, min, h, d, mon, y, res");
    {
	int	s = (int)SvIV(ST(0));
	int	min = (int)SvIV(ST(1));
	int	h = (int)SvIV(ST(2));
	int	d = (int)SvIV(ST(3));
	int	mon = (int)SvIV(ST(4));
	int	y = (int)SvIV(ST(5));
	SV*	res = ST(6);
#line 197 "HASP.xs"
	int s_1, min_1, h_1, d_1, mon_1, y_1;
	int rv;
#line 386 "HASP.c"
	int	RETVAL;
	dXSTARG;
#line 200 "HASP.xs"
	rv = _getDateTime(&s_1, &min_1, &h_1, &d_1, &mon_1, &y_1);
	if(rv == 0) {
		long date, date1, time, time1;
		date = y*10000 + mon*100 + d;
		date1 = y_1*10000 + mon_1*100 + d_1;
		time = h*10000 + min*100 + s;
		time1 = h_1*10000 + min_1*100 + s_1;
		if(date > date1 || ((date == date1) && (time > time1))) {
			sv_setiv(res, (IV) 1);
		} else if(date1 > date || ((date == date1) && (time1 > time))) {
			sv_setiv(res, (IV) -1);
		} else {
			sv_setiv(res, (IV) 0);
		}
	}
	RETVAL = rv;
#line 406 "HASP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_VN__HASP); /* prototype to pass -Wmissing-prototypes */
XS(boot_VN__HASP)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("VN::HASP::Attached", XS_VN__HASP_Attached, file);
        newXS("VN::HASP::DecodeData", XS_VN__HASP_DecodeData, file);
        newXS("VN::HASP::EncodeData", XS_VN__HASP_EncodeData, file);
        newXS("VN::HASP::Id", XS_VN__HASP_Id, file);
        newXS("VN::HASP::ReadBlock", XS_VN__HASP_ReadBlock, file);
        newXS("VN::HASP::WriteBlock", XS_VN__HASP_WriteBlock, file);
        newXS("VN::HASP::SetDateTime", XS_VN__HASP_SetDateTime, file);
        newXS("VN::HASP::GetDateTime", XS_VN__HASP_GetDateTime, file);
        newXS("VN::HASP::CompareTimeWithCurrent", XS_VN__HASP_CompareTimeWithCurrent, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

